# Критерий 4
**Разработка программы, осуществляющей взаимодействие между тремя родственными процессами одной программы с использованием неименованных каналов.**

## Требования:

### #1
***Представить общую схему решаемой задачи. При этом достаточно показать процессы и связи между ними через каналы, а также связи процессов с входным и выходным файлами.***

Общая схема работы программы представлена ниже:

**Процесс 1 (Чтение данных из файла)**: Открывает входной файл, читает данные в буфер и передает их через неименованный канал процессу 2.

**Процесс 2 (Обработка данных)**: Принимает данные из канала, осуществляет их обработку по заданному условию, и результат обработки отправляет через другой неименованный канал процессу 3.

**Процесс 3 (Запись данных в файл)**: Принимает обработанные данные из канала и записывает их в выходной файл.

### #2
***Разработать консольное приложение, использующее неименованные каналы, обеспечивающее взаимодействие по указанной схеме.***

Исходный код приложения можно найти в файле [main.c](main.c).

### #3
***Для задания имен входного и выходного файлов, а также дополнительных параметров, необходимых по условию задачи, использовать аргументы командной строки. В отчете необходимо описать формат аргументов командной строки и обеспечить его вывод при запуске программы с некорректными параметрами.***

В программе проверяется количество переданных аргументов и запуск отклоняется, если они не верны, с выводом справки:
```c
if (argc != 4) {
        fprintf(stderr, "Usage: %s <input file> <output file> <N>\n", argv[0]);
        exit(EXIT_FAILURE);
}
```

### #4
***Ввод и вывод данных при работе с файлами осуществлять через
системные вызовы операционной системы read и write.***

Пример использования системных вызовов в программе представлен ниже:
```c
if (cpid1 == 0) { // Child 1: Читает данные из файла и передает их через pipe
        close(pipefd1[0]); // Закрываем неиспользуемый конец чтения
        int input_fd = open(argv[1], O_RDONLY);
        if (input_fd == -1) {
            perror("open input file");
            exit(EXIT_FAILURE);
        }

        ssize_t bytes_read = read(input_fd, buffer, BUFFER_SIZE);
        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        write(pipefd1[1], buffer, bytes_read);
        close(pipefd1[1]);
        close(input_fd);
        exit(EXIT_SUCCESS);
}
```

### #5
***Размеры буферов для хранения вводимых данных и результатов
обработки должны быть равны 5000 байт.***

Размер буфера установлен в начале программы:
```c
#define BUFFER_SIZE 5000
```

### #6
***Программа должна работать с тестовыми данными, размер которых не должен превышать размера буфера. То есть, предполагается что весь обрабатываемый текст передается по каналу за один раз.***

Буфер заданного размера используется один раз для чтения и передачи данных:
```c
char buffer[BUFFER_SIZE] = {0};
```
```c
ssize_t bytes_read = read(input_fd, buffer, BUFFER_SIZE);
```
```c
ssize_t bytes_read = read(pipefd1[0], buffer, BUFFER_SIZE);
```
```c
ssize_t bytes_read = read(pipefd2[0], buffer, BUFFER_SIZE);
```

### #7
***Представить набор (не менее пяти) текстовых файлов, на которых проводилось тестирование программы.\
Для каждого из входных тестовых файлов в отчете должен быть представлен выходной файл, полученный в результате работы программы.\
Результаты работы должны быть представлены приведены в виде выходных данных.***

Для тестирования программы на языке C были написаны [Makefile](Makefile) и [программа-тестер](main.py) на языке Python.

Использование:
```bash
python main.py <количество тестов>
```

Тестер генерирует случайные данные. Для воспроизводимости результатов использован `random.seed()`. В директории [test](./test/) можно найти примеры, сгенерированные программой.

Исходя из результатов тестирования, можно сказать, что программа работает корректно:
```
cd build && ./app ../test/in/test_0.txt ../test/out/output_0.txt 4
Тест 1: УСПЕШНО
cd build && ./app ../test/in/test_1.txt ../test/out/output_1.txt 3
Тест 2: УСПЕШНО
cd build && ./app ../test/in/test_2.txt ../test/out/output_2.txt 5
Тест 3: УСПЕШНО
cd build && ./app ../test/in/test_3.txt ../test/out/output_3.txt 5
Тест 4: УСПЕШНО
cd build && ./app ../test/in/test_4.txt ../test/out/output_4.txt 3
Тест 5: УСПЕШНО
```