# Критерий 5
**В дополнение к требованиям и программе на предыдущую оценку необходимо разработать еще одну программу, в которой взаимодействие между тремя родственными процессами одной программы осуществляется через именованные каналы.**

## Требования:

### #1
***Представить общую схему решаемой задачи для именованных каналов. Достаточно показать процессы и связи между ними, а также связи процессов с входным и выходным файлами. Необходимо также указать имена каналов и способ их создания, используемый в работе.***

Общая схема работы программы представлена ниже:

**Процесс 1 (Чтение данных из файла)**: Открывает входной файл, читает данные, и передает их в именованный канал (FIFO 1), предназначенный для передачи данных к Процессу 2.

**Процесс 2 (Обработка данных)**: Считывает данные из именованного канала (FIFO 1), обрабатывает их согласно заданию (находит последнюю подпоследовательность из N символов, где каждый следующий символ больше предыдущего), и передает результат обработки в другой именованный канал (FIFO 2) для Процесса 3.

**Процесс 3 (Запись данных в файл)**: Считывает обработанные данные из именованного канала (FIFO 2) и записывает их в выходной файл.

Каналы создаюстся с помощью следующей функции:
```c
void create_fifo(const char *fifo_path) {
    if (mkfifo(fifo_path, 0666) && errno != EEXIST) {
        perror("mkfifo");
        exit(EXIT_FAILURE);
    }
}
```

### #2
***Разработать консольное приложение, использующее именованные каналы, обеспечивающее взаимодействие по указанной схеме.***

Исходный код приложения можно найти в файле [main.c](main.c).

### #3
***Для задания имен входного и выходного файлов, а также дополнительных параметров, необходимых по условию задачи, использовать аргументы командной строки. В отчете необходимо описать формат аргументов командной строки и обеспечить его вывод при запуске программы с некорректными параметрами.***

В программе проверяется количество переданных аргументов и запуск отклоняется, если они не верны, с выводом справки:
```c
if (argc != 4) {
        fprintf(stderr, "Usage: %s <input file> <output file> <N>\n", argv[0]);
        exit(EXIT_FAILURE);
}
```

### #4
***Ввод и вывод данных при работе с файлами осуществлять через
системные вызовы операционной системы read и write.***

Пример использования системных вызовов в программе представлен ниже:
```c
if (cpid1 == 0) {
        int input_fd = open(argv[1], O_RDONLY);
        int fifo1_fd = open(fifo1, O_WRONLY);
        char buffer[BUFFER_SIZE];
        ssize_t bytes_read;

        while ((bytes_read = read(input_fd, buffer, BUFFER_SIZE)) > 0) {
            write(fifo1_fd, buffer, bytes_read);
        }

        close(input_fd);
        close(fifo1_fd);
        exit(EXIT_SUCCESS);
    }
```

### #5
***Размеры буферов для хранения вводимых данных и результатов
обработки должны быть равны 5000 байт.***

Размер буфера установлен в начале программы:
```c
#define BUFFER_SIZE 5000
```

### #6
***Программа должна работать с тестовыми данными, размер которых не должен превышать размера буфера. То есть, предполагается что весь обрабатываемый текст передается по каналу за один раз.***

Буфер заданного размера используется один раз для чтения и передачи данных:
```c
char buffer[BUFFER_SIZE];
```
```c
ssize_t bytes_read = read(fifo1_fd, buffer, BUFFER_SIZE);
```

### #7
***Представить набор (не менее пяти) текстовых файлов, на которых проводилось тестирование программы.\
Для каждого из входных тестовых файлов в отчете должен быть представлен выходной файл, полученный в результате работы программы.\
Результаты работы должны быть представлены приведены в виде выходных данных.***

Для тестирования программы на языке C были написаны [Makefile](Makefile) и [программа-тестер](main.py) на языке Python.

Использование:
```bash
python main.py <количество тестов>
```

Тестер генерирует случайные данные. Для воспроизводимости результатов использован `random.seed()`. В директории [test](./test/) можно найти примеры, сгенерированные программой.

Исходя из результатов тестирования, можно сказать, что программа работает корректно:
```
cd build && ./app ../test/in/test_0.txt ../test/out/output_0.txt 5
Тест 1: УСПЕШНО
cd build && ./app ../test/in/test_1.txt ../test/out/output_1.txt 5
Тест 2: УСПЕШНО
cd build && ./app ../test/in/test_2.txt ../test/out/output_2.txt 3
Тест 3: УСПЕШНО
cd build && ./app ../test/in/test_3.txt ../test/out/output_3.txt 5
Тест 4: УСПЕШНО
cd build && ./app ../test/in/test_4.txt ../test/out/output_4.txt 3
Тест 5: УСПЕШНО
```