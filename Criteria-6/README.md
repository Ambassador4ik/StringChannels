# Критерий 6
**В дополнение к требованиям на предыдущую оценку разработать новую программу, которая осуществляет взаимодействие между двумя родственными процессами одной программы с использованием неименованных каналов.**

## Требования:

### #1
***Представить общую схему решаемой задачи для именованных каналов. Достаточно показать процессы и связи между ними, а также связи процессов с входным и выходным файлами. Необходимо также указать имена каналов и способ их создания, используемый в работе.***

Общая схема работы программы представлена ниже:

**Процесс 1 (Чтение и запись):**

Читает данные из входного файла.
Передает данные через неименованный канал процессу 2.
Принимает обработанные данные из неименованного канала от процесса 2.
Записывает полученные данные в выходной файл.

**Процесс 2 (Обработка данных):**

Принимает данные из неименованного канала от процесса 1.
Обрабатывает данные (находит последнюю подпоследовательность символов согласно условию задачи).
Отправляет обработанные данные обратно через неименованный канал процессу 1.

Неименованные каналы создаются с использованием системного вызова pipe().

```c
if (pipe(pipefd1) == -1 || pipe(pipefd2) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
}
```

### #2
***Разработать консольное приложение, использующее неименованные каналы, обеспечивающее взаимодействие по указанной схеме.***

Исходный код приложения можно найти в файле [main.c](main.c).

### #3
***Для задания имен входного и выходного файлов, а также дополнительных параметров, необходимых по условию задачи, использовать аргументы командной строки. В отчете необходимо описать формат аргументов командной строки и обеспечить его вывод при запуске программы с некорректными параметрами.***

В программе проверяется количество переданных аргументов и запуск отклоняется, если они не верны, с выводом справки:
```c
if (argc != 4) {
        fprintf(stderr, "Usage: %s <input file> <output file> <N>\n", argv[0]);
        exit(EXIT_FAILURE);
}
```

### #4
***Ввод и вывод данных при работе с файлами осуществлять через
системные вызовы операционной системы read и write.***

Пример использования системных вызовов в программе представлен ниже:
```c
ssize_t bytes_read = read(pipefd1[0], input, BUFFER_SIZE);
if (bytes_read > 0) {
    input[bytes_read] = '\0'; // Ensure null-termination
    char output[BUFFER_SIZE] = {0};
    process_data(input, output, N);
    write(pipefd2[1], output, strlen(output)); // Send processed data back
}
```

### #5
***Размеры буферов для хранения вводимых данных и результатов
обработки должны быть равны 5000 байт.***

Размер буфера установлен в начале программы:
```c
#define BUFFER_SIZE 5000
```

### #6
***Программа должна работать с тестовыми данными, размер которых не должен превышать размера буфера. То есть, предполагается что весь обрабатываемый текст передается по каналу за один раз.***

Буфер заданного размера используется один раз для чтения и передачи данных:
```c
char input[BUFFER_SIZE] = {0};
ssize_t bytes_read = read(pipefd1[0], input, BUFFER_SIZE);
```

### #7
***Представить набор (не менее пяти) текстовых файлов, на которых проводилось тестирование программы.\
Для каждого из входных тестовых файлов в отчете должен быть представлен выходной файл, полученный в результате работы программы.\
Результаты работы должны быть представлены приведены в виде выходных данных.***

Для тестирования программы на языке C были написаны [Makefile](Makefile) и [программа-тестер](main.py) на языке Python.

Использование:
```bash
python main.py <количество тестов>
```

Тестер генерирует случайные данные. Для воспроизводимости результатов использован `random.seed()`. В директории [test](./test/) можно найти примеры, сгенерированные программой.

Исходя из результатов тестирования, можно сказать, что программа работает корректно:
```
cd build && ./app ../test/in/test_0.txt ../test/out/output_0.txt 3
Тест 1: УСПЕШНО
cd build && ./app ../test/in/test_1.txt ../test/out/output_1.txt 5
Тест 2: УСПЕШНО
cd build && ./app ../test/in/test_2.txt ../test/out/output_2.txt 5
Тест 3: УСПЕШНО
cd build && ./app ../test/in/test_3.txt ../test/out/output_3.txt 3
Тест 4: УСПЕШНО
cd build && ./app ../test/in/test_4.txt ../test/out/output_4.txt 5
Тест 5: УСПЕШНО
```