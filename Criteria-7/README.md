# Критерий 7
**В дополнение к требованиям на предыдущую оценку разработать программу, которая осуществляет взаимодействие между двумя родственными процессами одной программы с использованием именованных каналов.**

## Требования:

### #1
***Представить общую схему решаемой задачи для именованных каналов. Достаточно показать процессы и связи между ними, а также связи процессов с входным и выходным файлами. Необходимо также указать имена каналов и способ их создания, используемый в работе.***

Общая схема работы программы представлена ниже:

**Процесс 1 (Чтение и запись):**

Читает данные из входного файла.
Передает данные через именованный канал (FIFO) процессу 2.
Принимает обработанные данные из другого именованного канала (FIFO) от процесса 2.
Записывает полученные данные в выходной файл.

**Процесс 2 (Обработка данных):**

Принимает данные из именованного канала (FIFO) от процесса 1.
Обрабатывает данные (находит последнюю подпоследовательность символов согласно условию задачи).
Отправляет обработанные данные через другой именованный канал (FIFO) обратно процессу 1.

**Имена каналов и способ их создания:** используются системные вызовы mkfifo для создания именованных каналов. Для нашей задачи потребуется создать два именованных канала, один для отправки данных от процесса 1 к процессу 2, и другой для отправки обработанных данных обратно.

```c
void create_fifo(const char *fifo_path) {
    if (mkfifo(fifo_path, 0666) == -1 && errno != EEXIST) {
        perror("mkfifo");
        exit(EXIT_FAILURE);
    }
}
```

### #2
***Разработать консольное приложение, использующее именованные каналы, обеспечивающее взаимодействие по указанной схеме.***

Исходный код приложения можно найти в файле [main.c](main.c).

### #3
***Для задания имен входного и выходного файлов, а также дополнительных параметров, необходимых по условию задачи, использовать аргументы командной строки. В отчете необходимо описать формат аргументов командной строки и обеспечить его вывод при запуске программы с некорректными параметрами.***

В программе проверяется количество переданных аргументов и запуск отклоняется, если они не верны, с выводом справки:
```c
if (argc != 4) {
        fprintf(stderr, "Usage: %s <input file> <output file> <N>\n", argv[0]);
        exit(EXIT_FAILURE);
}
```

### #4
***Ввод и вывод данных при работе с файлами осуществлять через
системные вызовы операционной системы read и write.***

Пример использования системных вызовов в программе представлен ниже:
```c
ssize_t bytes_read = read(fd_read, buffer, BUFFER_SIZE);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0'; // Null terminate the string
        char output[BUFFER_SIZE + 1];
        process_data(buffer, output, N);
        write(fd_write, output, strlen(output));
}
```

### #5
***Размеры буферов для хранения вводимых данных и результатов
обработки должны быть равны 5000 байт.***

Размер буфера установлен в начале программы:
```c
#define BUFFER_SIZE 5000
```

### #6
***Программа должна работать с тестовыми данными, размер которых не должен превышать размера буфера. То есть, предполагается что весь обрабатываемый текст передается по каналу за один раз.***

Буфер заданного размера используется один раз для чтения и передачи данных:
```c
char buffer[BUFFER_SIZE];
ssize_t bytes_read = read(fifo1_fd, buffer, BUFFER_SIZE);
```

### #7
***Представить набор (не менее пяти) текстовых файлов, на которых проводилось тестирование программы.\
Для каждого из входных тестовых файлов в отчете должен быть представлен выходной файл, полученный в результате работы программы.\
Результаты работы должны быть представлены приведены в виде выходных данных.***

Для тестирования программы на языке C были написаны [Makefile](Makefile) и [программа-тестер](main.py) на языке Python.

Использование:
```bash
python main.py <количество тестов>
```

Тестер генерирует случайные данные. Для воспроизводимости результатов использован `random.seed()`. В директории [test](./test/) можно найти примеры, сгенерированные программой.

Исходя из результатов тестирования, можно сказать, что программа работает корректно:
```
cd build && ./app ../test/in/test_0.txt ../test/out/output_0.txt 3
Тест 1: УСПЕШНО
cd build && ./app ../test/in/test_1.txt ../test/out/output_1.txt 3
Тест 2: УСПЕШНО
cd build && ./app ../test/in/test_2.txt ../test/out/output_2.txt 4
Тест 3: УСПЕШНО
cd build && ./app ../test/in/test_3.txt ../test/out/output_3.txt 3
Тест 4: УСПЕШНО
cd build && ./app ../test/in/test_4.txt ../test/out/output_4.txt 5
Тест 5: УСПЕШНО
```